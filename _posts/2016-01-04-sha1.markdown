---
layout: post
title:  "Building the SHA-1 Digest Algorithm in Object-Oriented Ruby"
date:   2016-01-04 11:19:00 -0700
categories: jekyll update
---

At the end of my first module at Turing, Jeff challenged me to complete a difficult coding challenge - building the SHA-1 digest algorithm from scratch using Ruby. I agreed, and proceeded to look up the [SHA-1 specification](http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf) from the National Institute of Standards and Technology. The secure hashing standard looks a lot like other engineering specifications I'm used to from previous jobs so the structure of the document was fairly familiar. However, a lot of the concepts were new to me.

I started with the preprocessing section and immediately got stuck when I encountered the line:

$$ l + 1 + k \equiv 448mod512 $$

What on earth does that mean? I found that throughout this project I ended up on Google and Stack Overflow researching a lot of the concepts. In this example, \\(l\\) is the length of the original message \\(M\\) in bits and \\(k\\)is the number of zero bits that are going to pad the message. That seems simple enough, so I originally tried to solve for \\(k\\). However, that approach becomes convoluted very quickly, and is difficult to solve for when the original message is longer than 448 bits. With some more searching, I realized that what you actually need to do is determine the minimum number of 512 bit words that can contain the entire message, plus the number one, plus the length encoded as a 64 bit binary message. This made the problem much easier to solve, because instead of figuring out how many zero bits of padding you need, you can simply figure out how many blocks you will need, add the message plus the number one to the beginning, append on zeros until you hit a multiple of 512 bits, and then remove the last 64 zeros and replace them with the length encoded as a 64 bit binary message.
